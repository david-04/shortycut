import { Hashtable } from "../utilities/hashtable";
import { Link } from "./link";
import { Links } from "./links";
import { MatchingSegment, Segment, Segments } from "./segments";
import { state } from "./state";

export type ShortcutType = "query" | "bookmark" | "both" | "none";

//----------------------------------------------------------------------------------------------------------------------
// Dynamic link functions
//----------------------------------------------------------------------------------------------------------------------

export type GeneratedLinks =
    | string
    | ReadonlyArray<string>
    | ReadonlyArray<{ readonly description: string; readonly url: string }>;

export type DynamicQueryFunction = (searchTerm: string) => GeneratedLinks;
export type DynamicBookmarkFunction = () => GeneratedLinks;
export type DynamicLinkFunction = DynamicQueryFunction | DynamicBookmarkFunction;

export interface DynamicShortcut {
    generator: DynamicQueryFunction;
    getFaviconUrls: () => readonly string[];
    isQuery: boolean;
}

//----------------------------------------------------------------------------------------------------------------------
// Finalized URLs (search term already embedded and generated by the dynamic link function if applicable)
//----------------------------------------------------------------------------------------------------------------------

export interface FinalizedPostField {
    key: string;
    value: string;
}

export type FinalizedPostFields = ReadonlyArray<FinalizedPostField>;

export interface FinalizedUrlBase {
    url: string;
    postFields?: FinalizedPostFields | undefined;
}

export interface FinalizedUrl extends FinalizedUrlBase {
    permalink: string;
}

export interface FinalizedLink {
    htmlDescription: string;
    urls: ReadonlyArray<FinalizedUrl>;
}

export interface FinalizedLinks {
    onMultiLink: OnMultiLink;
    links: readonly FinalizedLink[];
}

//----------------------------------------------------------------------------------------------------------------------
// Action to be taken if a keyword has multiple links
//----------------------------------------------------------------------------------------------------------------------

export class OnMultiLink {
    public static readonly values = new Array<OnMultiLink>();
    public static readonly byName: { [index: string]: OnMultiLink } = {};

    private constructor(public readonly key: string) {
        OnMultiLink.values.push(this);
        OnMultiLink.byName[this.key] = this;
    }

    public static getDefault() {
        return OnMultiLink.byName[state.config.shortcutFormat.url.multiLinkIndicator.default] || OnMultiLink.SHOW_MENU;
    }

    public static readonly REPLACE_PREVIOUS = new OnMultiLink("replacePrevious");
    public static readonly OPEN_IN_NEW_TAB = new OnMultiLink("openInNewTab");
    public static readonly SHOW_MENU = new OnMultiLink("showMenu");
    public static readonly SEARCH_BUCKET = new OnMultiLink("searchBucket");
}

//----------------------------------------------------------------------------------------------------------------------
// A shortcut that maps a single keyword to one or more URLs
//----------------------------------------------------------------------------------------------------------------------

export class Shortcut {
    private _bookmarks?: Links;
    private _queries?: Links;
    private _searchable?: Links;
    public readonly all = new Array<{ link: Link; links: Links }>();

    public get bookmarks() {
        return this._bookmarks;
    }

    public get queries() {
        return this._queries;
    }

    public get searchable() {
        return this._searchable;
    }

    public get type(): ShortcutType {
        if (this.bookmarks) {
            return this.queries ? "both" : "bookmark";
        } else if (this.queries) {
            return "query";
        } else {
            return "none";
        }
    }

    //------------------------------------------------------------------------------------------------------------------
    // Initialization
    //------------------------------------------------------------------------------------------------------------------

    constructor(
        public readonly keyword: string,
        segments: Segment[],
        onMultiLink: OnMultiLink,
        urlOrDynamicShortcut: string | DynamicShortcut
    ) {
        this.addLink(keyword, segments, onMultiLink, urlOrDynamicShortcut);
    }

    //------------------------------------------------------------------------------------------------------------------
    // Append a new link to the collection
    //------------------------------------------------------------------------------------------------------------------

    public addLink(
        keyword: string,
        segments: Segment[],
        onMultiLink: OnMultiLink,
        urlOrDynamicShortcut: string | DynamicShortcut
    ) {
        const link = new Link(
            keyword,
            this.all.length,
            new Segments(segments),
            OnMultiLink.SEARCH_BUCKET === onMultiLink ? OnMultiLink.getDefault() : onMultiLink,
            OnMultiLink.SEARCH_BUCKET === onMultiLink,
            urlOrDynamicShortcut
        );
        if (link.isSearchable) {
            this._searchable = this.createOrAdd(link, this._searchable);
        } else if (link.isQuery) {
            this._queries = this.createOrAdd(link, this._queries);
        } else {
            this._bookmarks = this.createOrAdd(link, this._bookmarks);
        }
    }

    //------------------------------------------------------------------------------------------------------------------
    // Append a link to the container (or create a new one if none is provided)
    //------------------------------------------------------------------------------------------------------------------

    private createOrAdd(link: Link, links?: Links) {
        if (links) {
            links.addLink(link);
        } else {
            links = new Links(link);
        }
        this.all[link.index] = { link, links };
        return links;
    }

    //------------------------------------------------------------------------------------------------------------------
    // Retrieve finalized links for all current bookmarks
    //------------------------------------------------------------------------------------------------------------------

    public getFinalizedBookmarks() {
        return this.createFinalizedLinks(this.bookmarks);
    }

    //------------------------------------------------------------------------------------------------------------------
    // Retrieve finalized links (with the search term inserted) for all current queries
    //------------------------------------------------------------------------------------------------------------------

    public getFinalizedQueries(searchTerm: string) {
        return this.createFinalizedLinks(this.queries, searchTerm);
    }

    //------------------------------------------------------------------------------------------------------------------
    // Retrieve the
    //------------------------------------------------------------------------------------------------------------------

    public getFinalizedLinks(searchTerm?: string) {
        return this.createFinalizedLinks(
            this.bookmarks && (!searchTerm?.trim() || !this.queries) ? this.bookmarks : this.queries,
            searchTerm
        );
    }

    //------------------------------------------------------------------------------------------------------------------
    // Convert the given links into finalized links
    //------------------------------------------------------------------------------------------------------------------

    private createFinalizedLinks(links?: Links | undefined, searchTerm?: string): FinalizedLinks {
        return (
            links?.toFinalizedLinks(searchTerm?.trim() ?? "") ?? { onMultiLink: OnMultiLink.OPEN_IN_NEW_TAB, links: [] }
        );
    }

    public getSegmentMatches(length: number) {
        const result = new Hashtable<MatchingSegment>();
        for (const link of [...(this._bookmarks?.current || []), ...(this.queries?.current || [])]) {
            const match = link.segments.getMatch(length);
            result.computeIfAbsent(match.fingerprint, () => match);
        }
        return result.values;
    }
}
